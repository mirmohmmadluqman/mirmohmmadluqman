<svg viewBox="0 0 2000 2000" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- Complex gradient definitions for depth -->
    <radialGradient id="voidCore">
      <stop offset="0%" stop-color="#ffffff" stop-opacity="1"/>
      <stop offset="5%" stop-color="#ffeedd" stop-opacity="0.95"/>
      <stop offset="10%" stop-color="#ffddcc" stop-opacity="0.9"/>
      <stop offset="15%" stop-color="#ffccbb" stop-opacity="0.85"/>
      <stop offset="20%" stop-color="#ffbbaa" stop-opacity="0.8"/>
      <stop offset="25%" stop-color="#ff9988" stop-opacity="0.75"/>
      <stop offset="30%" stop-color="#ff7766" stop-opacity="0.7"/>
      <stop offset="35%" stop-color="#ff5544" stop-opacity="0.65"/>
      <stop offset="40%" stop-color="#ee3333" stop-opacity="0.6"/>
      <stop offset="45%" stop-color="#dd2222" stop-opacity="0.55"/>
      <stop offset="50%" stop-color="#cc1111" stop-opacity="0.5"/>
      <stop offset="55%" stop-color="#aa0000" stop-opacity="0.45"/>
      <stop offset="60%" stop-color="#880000" stop-opacity="0.4"/>
      <stop offset="65%" stop-color="#660000" stop-opacity="0.35"/>
      <stop offset="70%" stop-color="#440000" stop-opacity="0.3"/>
      <stop offset="75%" stop-color="#220000" stop-opacity="0.25"/>
      <stop offset="80%" stop-color="#110000" stop-opacity="0.2"/>
      <stop offset="85%" stop-color="#080000" stop-opacity="0.15"/>
      <stop offset="90%" stop-color="#040000" stop-opacity="0.1"/>
      <stop offset="95%" stop-color="#020000" stop-opacity="0.05"/>
      <stop offset="100%" stop-color="#000000" stop-opacity="0"/>
    </radialGradient>
    
    <linearGradient id="dimensionalShift" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#ff00ff" stop-opacity="0.4">
        <animate attributeName="stop-color" values="#ff00ff;#00ffff;#ffff00;#ff00ff" dur="20s" repeatCount="indefinite"/>
      </stop>
      <stop offset="25%" stop-color="#00ffff" stop-opacity="0.4">
        <animate attributeName="stop-color" values="#00ffff;#ffff00;#ff00ff;#00ffff" dur="20s" repeatCount="indefinite"/>
      </stop>
      <stop offset="50%" stop-color="#ffff00" stop-opacity="0.4">
        <animate attributeName="stop-color" values="#ffff00;#ff00ff;#00ffff;#ffff00" dur="20s" repeatCount="indefinite"/>
      </stop>
      <stop offset="75%" stop-color="#ff00ff" stop-opacity="0.4">
        <animate attributeName="stop-color" values="#ff00ff;#00ffff;#ffff00;#ff00ff" dur="20s" repeatCount="indefinite"/>
      </stop>
      <stop offset="100%" stop-color="#00ffff" stop-opacity="0.4">
        <animate attributeName="stop-color" values="#00ffff;#ffff00;#ff00ff;#00ffff" dur="20s" repeatCount="indefinite"/>
      </stop>
    </linearGradient>
    
    <radialGradient id="quantumField">
      ${Array.from({length: 20}, (_, i) => 
        `<stop offset="${i * 5}%" stop-color="hsl(${i * 18}, 100%, 50%)" stop-opacity="${1 - i * 0.05}"/>`
      ).join('')}
    </radialGradient>
    
    <!-- Advanced filters -->
    <filter id="cosmicGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur1"/>
      <feGaussianBlur in="SourceGraphic" stdDeviation="8" result="blur2"/>
      <feGaussianBlur in="SourceGraphic" stdDeviation="16" result="blur3"/>
      <feMerge>
        <feMergeNode in="blur3"/>
        <feMergeNode in="blur2"/>
        <feMergeNode in="blur1"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    
    <filter id="dimensionalWarp">
      <feTurbulence baseFrequency="0.01" numOctaves="3" seed="5"/>
      <feDisplacementMap in="SourceGraphic" scale="10"/>
    </filter>
    
    <pattern id="sacredGrid" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
      <rect width="50" height="50" fill="none" stroke="#ffffff" stroke-width="0.1" opacity="0.1"/>
      <circle cx="25" cy="25" r="2" fill="#ffffff" opacity="0.2"/>
    </pattern>
  </defs>
  
  <!-- Deep space background -->
  <rect width="2000" height="2000" fill="#000000"/>
  
  <!-- Layer 0: Quantum foam background -->
  ${Array.from({length: 50000}, (_, i) => {
    const x = Math.random() * 2000;
    const y = Math.random() * 2000;
    const size = Math.random() * 3;
    const opacity = Math.random() * 0.6;
    const hue = Math.random() * 360;
    return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${hue}, 70%, 50%)" opacity="${opacity}">
      <animate attributeName="opacity" values="${opacity};${opacity * 0.3};${opacity}" dur="${3 + Math.random() * 5}s" repeatCount="indefinite"/>
    </circle>`;
  }).join('')}
  
  <!-- Layer 1: Dimensional grid -->
  <rect width="2000" height="2000" fill="url(#sacredGrid)"/>
  
  <!-- Layer 2: Primary sacred geometry ring system -->
  ${Array.from({length: 720}, (_, i) => {
    const angle = (i * 0.5 * Math.PI) / 180;
    const radius = 980;
    const x = 1000 + Math.cos(angle) * radius;
    const y = 1000 + Math.sin(angle) * radius;
    const innerRadius = 970 - Math.sin(i * 0.1) * 10;
    const ix = 1000 + Math.cos(angle) * innerRadius;
    const iy = 1000 + Math.sin(angle) * innerRadius;
    return `<line x1="${x}" y1="${y}" x2="${ix}" y2="${iy}" stroke="url(#dimensionalShift)" stroke-width="${0.5 + Math.sin(i * 0.05) * 0.3}" opacity="${0.6 + Math.sin(i * 0.02) * 0.3}"/>`;
  }).join('')}
  
  <!-- Layer 3: Multidimensional spiral systems -->
  ${Array.from({length: 24}, (_, spiral) => {
    const spiralAngle = (spiral * 15 * Math.PI) / 180;
    const spiralColor = `hsl(${spiral * 15}, 80%, 60%)`;
    return Array.from({length: 1000}, (_, i) => {
      const t = i / 100;
      const r = 900 * Math.exp(-t * 0.08);
      const angle = spiralAngle + t * 3 * Math.PI;
      const x = 1000 + r * Math.cos(angle);
      const y = 1000 + r * Math.sin(angle);
      const size = Math.max(0.1, 4 * Math.exp(-t * 0.2));
      const opacity = Math.max(0.1, Math.exp(-t * 0.15));
      return `<circle cx="${x}" cy="${y}" r="${size}" fill="${spiralColor}" opacity="${opacity}">
        <animate attributeName="r" values="${size};${size * 1.5};${size}" dur="${2 + spiral * 0.1}s" repeatCount="indefinite"/>
      </circle>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 4: Nested polygon systems -->
  ${Array.from({length: 12}, (_, poly) => {
    const sides = 3 + poly;
    const scale = 900 - poly * 60;
    return Array.from({length: sides}, (_, i) => {
      const angle1 = (i * 360 / sides * Math.PI) / 180;
      const angle2 = ((i + 1) * 360 / sides * Math.PI) / 180;
      const x1 = 1000 + Math.cos(angle1) * scale;
      const y1 = 1000 + Math.sin(angle1) * scale;
      const x2 = 1000 + Math.cos(angle2) * scale;
      const y2 = 1000 + Math.sin(angle2) * scale;
      return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="hsl(${poly * 30}, 70%, 50%)" stroke-width="0.5" opacity="${0.5 - poly * 0.03}"/>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 5: Flower of Life pattern -->
  ${Array.from({length: 19}, (_, ring) => {
    if (ring === 0) {
      return `<circle cx="1000" cy="1000" r="100" fill="none" stroke="#ffffff" stroke-width="0.5" opacity="0.4"/>`;
    }
    const angleStep = 60;
    return Array.from({length: 6}, (_, i) => {
      const angle = (i * angleStep * Math.PI) / 180;
      const ringRadius = 100 * Math.ceil(ring / 6);
      const x = 1000 + Math.cos(angle + (ring % 6) * 10 * Math.PI / 180) * ringRadius;
      const y = 1000 + Math.sin(angle + (ring % 6) * 10 * Math.PI / 180) * ringRadius;
      return `<circle cx="${x}" cy="${y}" r="100" fill="none" stroke="#ffffff" stroke-width="0.3" opacity="${0.3 - ring * 0.01}"/>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 6: Metatron's Cube -->
  ${(() => {
    const vertices = [];
    for (let i = 0; i < 6; i++) {
      const angle = (i * 60 * Math.PI) / 180;
      vertices.push([1000 + Math.cos(angle) * 300, 1000 + Math.sin(angle) * 300]);
    }
    vertices.push([1000, 1000]);
    for (let i = 0; i < 6; i++) {
      const angle = (i * 60 * Math.PI) / 180;
      vertices.push([1000 + Math.cos(angle) * 150, 1000 + Math.sin(angle) * 150]);
    }
    
    const lines = [];
    for (let i = 0; i < vertices.length; i++) {
      for (let j = i + 1; j < vertices.length; j++) {
        lines.push(`<line x1="${vertices[i][0]}" y1="${vertices[i][1]}" x2="${vertices[j][0]}" y2="${vertices[j][1]}" stroke="#00ffff" stroke-width="0.2" opacity="0.3"/>`);
      }
    }
    return lines.join('');
  })()}
  
  <!-- Layer 7: Sri Yantra -->
  ${(() => {
    const triangles = [];
    for (let i = 0; i < 9; i++) {
      const scale = 1 - i * 0.1;
      const rotation = i * 20;
      if (i % 2 === 0) {
        triangles.push(`
          <g transform="rotate(${rotation} 1000 1000)">
            <path d="M 1000,${1000 - 400 * scale} L ${1000 - 346 * scale},${1000 + 200 * scale} L ${1000 + 346 * scale},${1000 + 200 * scale} Z" 
                  fill="none" stroke="#ff00ff" stroke-width="0.5" opacity="${0.4 - i * 0.03}"/>
          </g>
        `);
      } else {
        triangles.push(`
          <g transform="rotate(${rotation} 1000 1000)">
            <path d="M 1000,${1000 + 400 * scale} L ${1000 - 346 * scale},${1000 - 200 * scale} L ${1000 + 346 * scale},${1000 - 200 * scale} Z" 
                  fill="none" stroke="#ffff00" stroke-width="0.5" opacity="${0.4 - i * 0.03}"/>
          </g>
        `);
      }
    }
    return triangles.join('');
  })()}
  
  <!-- Layer 8: Torus field visualization -->
  ${Array.from({length: 100}, (_, i) => {
    const u = (i / 100) * Math.PI * 2;
    return Array.from({length: 50}, (_, j) => {
      const v = (j / 50) * Math.PI * 2;
      const R = 300;
      const r = 100;
      const x = 1000 + (R + r * Math.cos(v)) * Math.cos(u);
      const y = 1000 + (R + r * Math.cos(v)) * Math.sin(u);
      const z = r * Math.sin(v);
      const size = 1 + z / 100;
      const opacity = 0.3 + z / 200;
      return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${u * 180 / Math.PI}, 70%, 50%)" opacity="${opacity}"/>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 9: Fibonacci spiral galaxy -->
  ${Array.from({length: 8}, (_, arm) => {
    const armAngle = arm * 45;
    const golden = 1.618033988749895;
    return Array.from({length: 500}, (_, i) => {
      const angle = i * 0.1;
      const r = Math.pow(golden, angle * 0.2) * 20;
      const x = 1000 + r * Math.cos(angle + armAngle * Math.PI / 180);
      const y = 1000 + r * Math.sin(angle + armAngle * Math.PI / 180);
      const size = Math.max(0.5, 4 - i * 0.008);
      const hue = (armAngle + i) % 360;
      return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${hue}, 80%, 60%)" opacity="${0.5 - i * 0.001}"/>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 10: Quantum field fluctuations -->
  ${Array.from({length: 20000}, (_, i) => {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * 800;
    const x = 1000 + r * Math.cos(angle);
    const y = 1000 + r * Math.sin(angle);
    const size = Math.random() * 2;
    const opacity = (1 - r / 800) * 0.5;
    const hue = (r / 800) * 360;
    return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${hue}, 100%, 50%)" opacity="${opacity}"/>`;
  }).join('')}
  
  <!-- Layer 11: Nested Mandala rings -->
  ${Array.from({length: 30}, (_, ring) => {
    const radius = 800 - ring * 25;
    const elements = 12 + ring * 2;
    return Array.from({length: elements}, (_, i) => {
      const angle = (i * 360 / elements * Math.PI) / 180;
      const x = 1000 + Math.cos(angle) * radius;
      const y = 1000 + Math.sin(angle) * radius;
      const size = 20 - ring * 0.5;
      return `
        <g transform="translate(${x}, ${y}) rotate(${i * 360 / elements})">
          <rect x="${-size/2}" y="${-size/2}" width="${size}" height="${size}" fill="none" stroke="#00ff00" stroke-width="0.3" opacity="${0.4 - ring * 0.01}"/>
          <circle cx="0" cy="0" r="${size * 0.7}" fill="none" stroke="#ff00ff" stroke-width="0.2" opacity="${0.3 - ring * 0.01}"/>
          <path d="M 0,${-size/2} L ${size/2},0 L 0,${size/2} L ${-size/2},0 Z" fill="none" stroke="#ffff00" stroke-width="0.2" opacity="${0.3 - ring * 0.01}"/>
        </g>
      `;
    }).join('');
  }).join('')}
  
  <!-- Layer 12: DNA Double Helix -->
  ${Array.from({length: 200}, (_, i) => {
    const t = i * 0.1;
    const radius = 150 - i * 0.5;
    const x1 = 1000 + Math.cos(t) * radius;
    const y1 = 800 + i * 4;
    const x2 = 1000 - Math.cos(t) * radius;
    const y2 = 800 + i * 4;
    const hue1 = (i * 2) % 360;
    const hue2 = (i * 2 + 180) % 360;
    return `
      <circle cx="${x1}" cy="${y1}" r="3" fill="hsl(${hue1}, 80%, 50%)" opacity="0.5"/>
      <circle cx="${x2}" cy="${y2}" r="3" fill="hsl(${hue2}, 80%, 50%)" opacity="0.5"/>
      <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#ffffff" stroke-width="0.5" opacity="0.2"/>
    `;
  }).join('')}
  
  <!-- Layer 13: Platonic Solids projection -->
  ${(() => {
    // Icosahedron vertices
    const phi = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],
      [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],
      [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1]
    ];
    
    const scale = 100;
    const projected = vertices.map(([x, y, z]) => {
      const perspective = 2 / (2 + z * 0.01);
      return [1000 + x * scale * perspective, 1000 + y * scale * perspective];
    });
    
    const edges = [];
    for (let i = 0; i < projected.length; i++) {
      for (let j = i + 1; j < projected.length; j++) {
        const [x1, y1] = projected[i];
        const [x2, y2] = projected[j];
        const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        if (dist < 220) {
          edges.push(`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#00ffff" stroke-width="0.5" opacity="0.4"/>`);
        }
      }
    }
    return edges.join('');
  })()}
  
  <!-- Layer 14: Fractal tree network -->
  ${(() => {
    const branches = [];
    const drawBranch = (x, y, angle, length, depth, hue) => {
      if (depth === 0 || length < 2) return;
      const x2 = x + Math.cos(angle) * length;
      const y2 = y + Math.sin(angle) * length;
      branches.push(`<line x1="${x}" y1="${y}" x2="${x2}" y2="${y2}" stroke="hsl(${hue}, 70%, 50%)" stroke-width="${depth * 0.5}" opacity="${depth * 0.15}"/>`);
      
      const angleVariation = 0.2 + Math.random() * 0.3;
      const lengthReduction = 0.6 + Math.random() * 0.2;
      
      drawBranch(x2, y2, angle - angleVariation, length * lengthReduction, depth - 1, hue + 10);
      drawBranch(x2, y2, angle + angleVariation, length * lengthReduction, depth - 1, hue - 10);
      if (Math.random() > 0.5) {
        drawBranch(x2, y2, angle, length * lengthReduction * 0.8, depth - 1, hue);
      }
    };
    
    for (let i = 0; i < 12; i++) {
      const angle = (i * 30 * Math.PI) / 180;
      drawBranch(1000, 1000, angle, 80, 7, i * 30);
    }
    return branches.join('');
  })()}
  
  <!-- Layer 15: Sierpinski Carpet -->
  ${(() => {
    const squares = [];
    const sierpinski = (x, y, size, depth) => {
      if (depth === 0) {
        squares.push(`<rect x="${x}" y="${y}" width="${size}" height="${size}" fill="none" stroke="#ff66cc" stroke-width="0.2" opacity="0.3"/>`);
      } else {
        const newSize = size / 3;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (i !== 1 || j !== 1) {
              sierpinski(x + i * newSize, y + j * newSize, newSize, depth - 1);
            }
          }
        }
      }
    };
    sierpinski(700, 700, 600, 4);
    return squares.join('');
  })()}
  
  <!-- Layer 16: Julia Set -->
  ${Array.from({length: 30000}, (_, i) => {
    const x0 = (Math.random() - 0.5) * 4;
    const y0 = (Math.random() - 0.5) * 4;
    let x = x0, y = y0;
    const c_re = -0.8;
    const c_im = 0.156;
    let iter;
    for (iter = 0; iter < 50; iter++) {
      const x_new = x * x - y * y + c_re;
      const y_new = 2 * x * y + c_im;
      x = x_new;
      y = y_new;
      if (x * x + y * y > 4) break;
    }
    if (iter < 50) {
      const px = 1000 + x0 * 150;
      const py = 1000 + y0 * 150;
      const hue = (iter * 7) % 360;
      return `<circle cx="${px}" cy="${py}" r="0.5" fill="hsl(${hue}, 80%, 50%)" opacity="${0.6 - iter * 0.01}"/>`;
    }
    return '';
  }).join('')}
  
  <!-- Layer 17: Strange Attractor (Rössler) -->
  ${(() => {
    const points = [];
    let x = 0.1, y = 0, z = 0;
    const a = 0.2, b = 0.2, c = 5.7;
    const dt = 0.01;
    for (let i = 0; i < 10000; i++) {
      const dx = -y - z;
      const dy = x + a * y;
      const dz = b + z * (x - c);
      x += dx * dt;
      y += dy * dt;
      z += dz * dt;
      const px = 1000 + x * 30;
      const py = 1000 + y * 30;
      const hue = (z * 10 + 180) % 360;
      points.push(`<circle cx="${px}" cy="${py}" r="0.3" fill="hsl(${hue}, 70%, 50%)" opacity="0.3"/>`);
    }
    return points.join('');
  })()}
  
  <!-- Layer 18: Penrose Tiling -->
  ${(() => {
    const tiles = [];
    const phi = (1 + Math.sqrt(5)) / 2;
    for (let ring = 0; ring < 10; ring++) {
      for (let i = 0; i < 10; i++) {
        const angle = (i * 36 * Math.PI) / 180;
        const r = 100 + ring * 60;
        const x = 1000 + Math.cos(angle) * r;
        const y = 1000 + Math.sin(angle) * r;
        const rotation = i * 36 + ring * 18;
        const scale = 30;
        tiles.push(`
          <g transform="translate(${x}, ${y}) rotate(${rotation})">
            <path d="M 0,0 L ${scale * phi},0 L ${scale * phi / 2},${scale * Math.sin(72 * Math.PI / 180)} Z" 
                  fill="none" stroke="hsl(${rotation % 360}, 70%, 50%)" stroke-width="0.3" opacity="0.3"/>
            <path d="M 0,0 L ${scale},${scale * Math.tan(36 * Math.PI / 180)} L ${scale * phi},0 Z" 
                  fill="none" stroke="hsl(${(rotation + 180) % 360}, 70%, 50%)" stroke-width="0.3" opacity="0.3"/>
          </g>
        `);
      }
    }
    return tiles.join('');
  })()}
  
  <!-- Layer 19: Hyperbolic tessellation -->
  ${(() => {
    const hyperbolic = [];
    for (let level = 0; level < 5; level++) {
      const n = Math.pow(3, level) * 4;
      for (let i = 0; i < n; i++) {
        const angle = (i * 360 / n * Math.PI) / 180;
        const r = 200 * Math.tanh(level * 0.5);
        const x = 1000 + r * Math.cos(angle);
        const y = 1000 + r * Math.sin(angle);
        const size = 30 / (level + 1);
        hyperbolic.push(`
          <g transform="translate(${x}, ${y}) rotate(${i * 360 / n})">
            <polygon points="0,-${size} ${size * 0.866},${size * 0.5} ${-size * 0.866},${size * 0.5}" 
                     fill="none" stroke="#00ff00" stroke-width="0.2" opacity="${0.4 - level * 0.08}"/>
          </g>
        `);
      }
    }
    return hyperbolic.join('');
  })()}
  
  <!-- Layer 20: Klein Bottle projection -->
  ${Array.from({length: 200}, (_, i) => {
    const u = (i / 200) * Math.PI * 2;
    return Array.from({length: 100}, (_, j) => {
      const v = (j / 100) * Math.PI * 2;
      const r = 4 - Math.cos(u);
      const x = 1000 + 40 * (6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(u) * Math.cos(v));
      const y = 1000 + 40 * (16 * Math.sin(u) + r * Math.sin(u) * Math.cos(v));
      const z = r * Math.sin(v);
      const size = 0.5 + Math.abs(z) / 10;
      const hue = (u * 180 / Math.PI + v * 90 / Math.PI) % 360;
      return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${hue}, 70%, 50%)" opacity="0.3"/>`; 
    }).join('');
  }).join('')}
  
  <!-- Layer 21: Dragon Curve -->
  ${(() => {
    const dragonCurve = (n) => {
      let result = 'R';
      for (let i = 0; i < n; i++) {
        let temp = '';
        for (let j = result.length - 1; j >= 0; j--) {
          temp += result[j] === 'R' ? 'L' : 'R';
        }
        result = result + 'R' + temp;
      }
      return result;
    };
    const curve = dragonCurve(13);
    let x = 1200, y = 1000;
    let dir = 0;
    const step = 3;
    const path = [`M ${x} ${y}`];
    for (let i = 0; i < curve.length; i++) {
      x += Math.cos(dir) * step;
      y += Math.sin(dir) * step;
      path.push(`L ${x} ${y}`);
      dir += curve[i] === 'R' ? Math.PI / 2 : -Math.PI / 2;
    }
    return `<path d="${path.join(' ')}" fill="none" stroke="#ffff00" stroke-width="0.4" opacity="0.4"/>`;
  })()}
  
  <!-- Layer 22: Apollonian Gasket -->
  ${(() => {
    const circles = [];
    const apollonian = (x, y, r, depth, hue) => {
      if (depth === 0 || r < 2) return;
      circles.push(`<circle cx="${x}" cy="${y}" r="${r}" fill="none" stroke="hsl(${hue}, 80%, 50%)" stroke-width="0.3" opacity="${0.4 - depth * 0.05}"/>`);
      
      const k1 = 1 / r;
      const k2 = k1 * (3 + 2 * Math.sqrt(3));
      const r2 = 1 / k2;
      
      const angles = [0, 120, 240];
      angles.forEach((angle, i) => {
        const rad = angle * Math.PI / 180;
        const nx = x + (r - r2) * Math.cos(rad);
        const ny = y + (r - r2) * Math.sin(rad);
        apollonian(nx, ny, r2, depth - 1, (hue + 30) % 360);
      });
    };
    apollonian(1000, 1000, 200, 6, 0);
    return circles.join('');
  })()}
  
  <!-- Layer 23: Hilbert Curve -->
  ${(() => {
    const hilbert = (n) => {
      const hilbertIndex = (i, n) => {
        let x = 0, y = 0;
        let s = 1;
        const size = Math.pow(2, n);
        while (s < size) {
          const rx = 1 & (i >> 1);
          const ry = 1 & (i ^ rx);
          if (ry === 0) {
            if (rx === 1) {
              x = s - 1 - x;
              y = s - 1 - y;
            }
            [x, y] = [y, x];
          }
          x += s * rx;
          y += s * ry;
          i >>= 2;
          s <<= 1;
        }
        return [x, y];
      };
      
      const size = Math.pow(2, n);
      const path = [];
      for (let i = 0; i < size * size; i++) {
        path.push(hilbertIndex(i, n));
      }
      return path;
    };
    
    const points = hilbert(6);
    const scale = 8;
    const offset = 600;
    const pathStr = points.map(([x, y], i) => 
      `${i === 0 ? 'M' : 'L'} ${offset + x * scale} ${offset + y * scale}`
    ).join(' ');
    return `<path d="${pathStr}" fill="none" stroke="#00ffff" stroke-width="0.3" opacity="0.4"/>`;
  })()}
  
  <!-- Layer 24: Gosper Curve -->
  ${(() => {
    const gosperCurve = (n) => {
      let axiom = 'A';
      const rules = {
        'A': 'A+B++B-A--AA-B+',
        'B': '-A+BB++B+A--A-B'
      };
      for (let i = 0; i < n; i++) {
        let next = '';
        for (let char of axiom) {
          next += rules[char] || char;
        }
        axiom = next;
      }
      return axiom;
    };
    
    const curve = gosperCurve(4);
    let x = 1400, y = 800;
    let angle = 0;
    const step = 4;
    const path = [`M ${x} ${y}`];
    
    for (let char of curve) {
      if (char === 'A' || char === 'B') {
        x += Math.cos(angle) * step;
        y += Math.sin(angle) * step;
        path.push(`L ${x} ${y}`);
      } else if (char === '+') {
        angle += Math.PI / 3;
      } else if (char === '-') {
        angle -= Math.PI / 3;
      }
    }
    return `<path d="${path.join(' ')}" fill="none" stroke="#ff66cc" stroke-width="0.3" opacity="0.4"/>`;
  })()}
  
  <!-- Layer 25: Mandelbrot Set boundary -->
  ${Array.from({length: 10000}, (_, i) => {
    const angle = (i / 10000) * Math.PI * 2;
    const c_re = Math.cos(angle) * 2;
    const c_im = Math.sin(angle) * 2;
    let x = 0, y = 0;
    let bounded = true;
    let iter;
    for (iter = 0; iter < 100; iter++) {
      const x_new = x * x - y * y + c_re;
      const y_new = 2 * x * y + c_im;
      x = x_new;
      y = y_new;
      if (x * x + y * y > 4) {
        bounded = false;
        break;
      }
    }
    if (bounded) {
      const px = 1000 + c_re * 200;
      const py = 1000 + c_im * 200;
      return `<circle cx="${px}" cy="${py}" r="0.5" fill="#ffffff" opacity="0.5"/>`;
    } else if (iter > 10) {
      const px = 1000 + c_re * 200;
      const py = 1000 + c_im * 200;
      const hue = (iter * 3.6) % 360;
      return `<circle cx="${px}" cy="${py}" r="0.3" fill="hsl(${hue}, 80%, 50%)" opacity="${0.3 + iter * 0.003}"/>`;
    }
    return '';
  }).join('')}
  
  <!-- Layer 26: Lorenz Attractor -->
  ${(() => {
    const points = [];
    let x = 0.1, y = 0, z = 0;
    const sigma = 10, rho = 28, beta = 8/3;
    const dt = 0.01;
    for (let i = 0; i < 5000; i++) {
      const dx = sigma * (y - x) * dt;
      const dy = (x * (rho - z) - y) * dt;
      const dz = (x * y - beta * z) * dt;
      x += dx;
      y += dy;
      z += dz;
      const px = 1000 + x * 15;
      const py = 1000 + (y - 20) * 15;
      const hue = (z * 5 + 180) % 360;
      points.push(`<circle cx="${px}" cy="${py}" r="0.4" fill="hsl(${hue}, 70%, 50%)" opacity="0.3"/>`);
    }
    return points.join('');
  })()}
  
  <!-- Layer 27: Torus Knot -->
  ${Array.from({length: 1000}, (_, i) => {
    const t = (i / 1000) * Math.PI * 2;
    const p = 3;
    const q = 8;
    const r = Math.cos(q * t) + 2;
    const x = 1000 + 60 * r * Math.cos(p * t);
    const y = 1000 + 60 * r * Math.sin(p * t);
    const z = 60 * Math.sin(q * t);
    const size = 1.5 + z / 60;
    const hue = (t * 180 / Math.PI) % 360;
    return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${hue}, 80%, 50%)" opacity="0.4"/>`;
  }).join('')}
  
  <!-- Layer 28: Cellular Automaton -->
  ${(() => {
    const cells = [];
    const rule = 30;
    const size = 100;
    let row = new Array(size).fill(0);
    row[Math.floor(size / 2)] = 1;
    
    for (let y = 0; y < 50; y++) {
      for (let x = 0; x < size; x++) {
        if (row[x] === 1) {
          cells.push(`<rect x="${750 + x * 5}" y="${200 + y * 5}" width="4" height="4" fill="hsl(${y * 7}, 70%, 50%)" opacity="0.4"/>`);
        }
      }
      const newRow = new Array(size).fill(0);
      for (let x = 0; x < size; x++) {
        const left = row[(x - 1 + size) % size];
        const center = row[x];
        const right = row[(x + 1) % size];
        const pattern = (left << 2) | (center << 1) | right;
        newRow[x] = (rule >> pattern) & 1;
      }
      row = newRow;
    }
    return cells.join('');
  })()}
  
  <!-- Layer 29: Voronoi Tessellation -->
  ${(() => {
    const seeds = Array.from({length: 50}, () => ({
      x: Math.random() * 1000 + 500,
      y: Math.random() * 1000 + 500,
      hue: Math.random() * 360
    }));
    
    const voronoi = [];
    for (let x = 500; x < 1500; x += 10) {
      for (let y = 500; y < 1500; y += 10) {
        let minDist = Infinity;
        let nearestSeed = null;
        for (let seed of seeds) {
          const dist = Math.sqrt((x - seed.x) ** 2 + (y - seed.y) ** 2);
          if (dist < minDist) {
            minDist = dist;
            nearestSeed = seed;
          }
        }
        if (nearestSeed && minDist < 200) {
          voronoi.push(`<circle cx="${x}" cy="${y}" r="2" fill="hsl(${nearestSeed.hue}, 70%, 50%)" opacity="${0.3 - minDist / 400}"/>`);
        }
      }
    }
    return voronoi.join('');
  })()}
  
  <!-- Layer 30: Quaternion Julia Set -->
  ${Array.from({length: 20000}, (_, i) => {
    const x0 = (Math.random() - 0.5) * 3;
    const y0 = (Math.random() - 0.5) * 3;
    const z0 = (Math.random() - 0.5) * 3;
    let x = x0, y = y0, z = z0, w = 0;
    const c = {x: -0.2, y: 0.6, z: -0.2, w: -0.2};
    let iter;
    for (iter = 0; iter < 20; iter++) {
      const r2 = x*x + y*y + z*z + w*w;
      if (r2 > 4) break;
      const tmp = x;
      x = x*x - y*y - z*z - w*w + c.x;
      y = 2*tmp*y + c.y;
      z = 2*tmp*z + c.z;
      w = 2*tmp*w + c.w;
    }
    if (iter > 5 && iter < 20) {
      const px = 1000 + x0 * 200;
      const py = 1000 + y0 * 200;
      const hue = (iter * 18) % 360;
      return `<circle cx="${px}" cy="${py}" r="0.5" fill="hsl(${hue}, 80%, 50%)" opacity="${0.4 - iter * 0.02}"/>`;
    }
    return '';
  }).join('')}
  
  <!-- Layer 31: Sacred Lotus -->
  ${Array.from({length: 32}, (_, i) => {
    const angle = (i * 11.25 * Math.PI) / 180;
    const r1 = 200 + Math.sin(angle * 4) * 50;
    const r2 = 250 + Math.sin(angle * 4) * 50;
    const cx1 = 1000 + Math.cos(angle) * r1;
    const cy1 = 1000 + Math.sin(angle) * r1;
    const cx2 = 1000 + Math.cos(angle) * r2;
    const cy2 = 1000 + Math.sin(angle) * r2;
    const controlX = 1000 + Math.cos(angle + 0.1) * ((r1 + r2) / 2);
    const controlY = 1000 + Math.sin(angle + 0.1) * ((r1 + r2) / 2);
    return `<path d="M ${cx1},${cy1} Q ${controlX},${controlY} ${cx2},${cy2}" fill="none" stroke="hsl(${i * 11.25}, 70%, 50%)" stroke-width="0.5" opacity="0.4"/>`;
  }).join('')}
  
  <!-- Layer 32: Energy vortex -->
  ${Array.from({length: 20}, (_, vortex) => {
    const phase = vortex * Math.PI / 10;
    return Array.from({length: 100}, (_, i) => {
      const t = i * 0.1;
      const r = 300 * Math.exp(-t * 0.15) * (1 + Math.sin(t * 3 + phase) * 0.2);
      const angle = t * 2 + phase;
      const x = 1000 + r * Math.cos(angle);
      const y = 1000 + r * Math.sin(angle);
      const size = 2 * Math.exp(-t * 0.2);
      const opacity = 0.3 * Math.exp(-t * 0.1);
      return `<circle cx="${x}" cy="${y}" r="${size}" fill="hsl(${vortex * 18 + t * 10}, 80%, 60%)" opacity="${opacity}"/>`;
    }).join('');
  }).join('')}
  
  <!-- Layer 33: Quantum entanglement visualization -->
  ${Array.from({length: 100}, (_, i) => {
    const angle1 = Math.random() * Math.PI * 2;
    const angle2 = angle1 + Math.PI;
    const r = 200 + Math.random() * 200;
    const x1 = 1000 + Math.cos(angle1) * r;
    const y1 = 1000 + Math.sin(angle1) * r;
    const x2 = 1000 + Math.cos(angle2) * r;
    const y2 = 1000 + Math.sin(angle2) * r;
    const hue = Math.random() * 360;
    return `
      <circle cx="${x1}" cy="${y1}" r="3" fill="hsl(${hue}, 80%, 50%)" opacity="0.5"/>
      <circle cx="${x2}" cy="${y2}" r="3" fill="hsl(${hue}, 80%, 50%)" opacity="0.5"/>
      <path d="M ${x1},${y1} Q 1000,1000 ${x2},${y2}" fill="none" stroke="hsl(${hue}, 60%, 50%)" stroke-width="0.2" opacity="0.2"/>
    `;
  }).join('')}
  
  <!-- Layer 34: Cosmic web structure -->
  ${(() => {
    const nodes = Array.from({length: 100}, () => ({
      x: Math.random() * 1600 + 200,
      y: Math.random() * 1600 + 200,
      connections: []
    }));
    
    // Connect nearby nodes
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dist = Math.sqrt((nodes[i].x - nodes[j].x) ** 2 + (nodes[i].y - nodes[j].y) ** 2);
        if (dist < 150) {
          nodes[i].connections.push(j);
        }
      }
    }
    
    const lines = [];
    for (let i = 0; i < nodes.length; i++) {
      for (let j of nodes[i].connections) {
        lines.push(`<line x1="${nodes[i].x}" y1="${nodes[i].y}" x2="${nodes[j].x}" y2="${nodes[j].y}" stroke="#ffffff" stroke-width="0.2" opacity="0.2"/>`);
      }
      lines.push(`<circle cx="${nodes[i].x}" cy="${nodes[i].y}" r="2" fill="#ffffff" opacity="0.4"/>`);
    }
    return lines.join('');
  })()}
  
  <!-- Layer 35: Final core mandala -->
  <g transform="translate(1000, 1000)" filter="url(#cosmicGlow)">
    ${Array.from({length: 12}, (_, i) => {
      const angle = i * 30;
      return `
        <g transform="rotate(${angle})">
          <ellipse cx="0" cy="0" rx="150" ry="50" fill="none" stroke="url(#quantumField)" stroke-width="1" opacity="0.5"/>
          <line x1="0" y1="-150" x2="0" y2="150" stroke="url(#dimensionalShift)" stroke-width="0.5" opacity="0.4"/>
          <circle cx="0" cy="100" r="20" fill="none" stroke="#ffffff" stroke-width="0.5" opacity="0.3"/>
        </g>
      `;
    }).join('')}
    
    <!-- Central singularity -->
    <circle cx="0" cy="0" r="80" fill="url(#voidCore)" opacity="0.8"/>
    <circle cx="0" cy="0" r="60" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.6"/>
    <circle cx="0" cy="0" r="40" fill="none" stroke="#ffffff" stroke-width="0.5" opacity="0.4"/>
    <circle cx="0" cy="0" r="20" fill="none" stroke="#ffffff" stroke-width="0.3" opacity="0.2"/>
    <circle cx="0" cy="0" r="5" fill="#ffffff" opacity="1"/>
  </g>
  
  <!-- Animated elements -->
  <g transform="translate(1000, 1000)">
    ${Array.from({length: 6}, (_, i) => {
      const angle = i * 60;
      return `
        <circle r="300" fill="none" stroke="url(#dimensionalShift)" stroke-width="0.5" opacity="0.2">
          <animateTransform attributeName="transform" type="rotate" from="0" to="${i % 2 ? 360 : -360}" dur="${30 + i * 5}s" repeatCount="indefinite"/>
        </circle>
      `;
    }).join('')}
  </g>
</svg>

